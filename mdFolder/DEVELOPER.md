# Project Name

Big Data and Cloud System Platform

## Table of Contents

- [About](#about)
- [Frontend](#frontend)
- [Backend](#backend)
- [Jupyter Notebook](#jupyter-notebook)
- [Installation](#installation)
- [Usage](#usage)
- [Contributing](#contributing)
- [License](#license)

## About

This is a platform that visualizes individual city weather information for 14 representative cities in Oregon and visualizes weather information between two cities, taking the motif of the Google Maps weather platform using Weather Open API. By building Docker images for code for the front-end, back-end, and Jupyter notebooks, we containerize the code and automate data updates by converging Kubernetes and CI/CD. Users create city information they want to know on the front end, and the extracted information is sent to the back end in json file format. In the backend, data generated by the Weather Open API is stored in the AWS RC2 MySQL database, and the backend and Jupyter notebook connected to the database fetch and store the data. Since the platform was set to target all ages, we pursued a UI/UX design that anyone can use by introducing Google Maps, using classic buttons, and using markers. Targeting all ages means users do not need any background knowledge to use the platform, and this has been introduced to increase the user experience.

## Frontend

### Overview

We constructed a component tree using a React application. It consists of 5 pages including navigation.

1. people
2. product
3. login
4. resources
5. platform

The error page is defined in the <Error> component, and the component tree starts from the <Root> page.

Each page consists of the following components and user interface.

- People
PersonCard Component: Displays the names and information of project members.

- Product
Landing Page Component: This is an overview that explains the project description, target, and purpose.

- Login
Login Component: This is a user login component that distinguishes between administrators and users. Administrators are given two buttons, one to update the information about each city. It is stored in AWS Database, and there is a table corresponding to the city name in the database and updates the city data. The other is a button for automation, which allows the administrator to update the server if updated code exists on GitHub.

- Resources
Resources Component: Records the platform version and shares usage instructions. We also provide a link to download the platform's Docker container.

- Platform: This is the component where the platform is located. Users require three interactions:

    1. Provide two city names: Provide two city names in the two white input boxes provided in the Platform component.

    Each city input box consists of cityName1 and cityName2 React states. 
    The user enters the city name provided by the database into the input box using the keyboard. The cities we serve are: 

    Locations: Corvallis, Bend, Beaverton, Eugene, Grants Pass, Gresham, Hilsboro, Hood River, Lake Oswego, Oregon City, Portland, Roseburg, Salem, Tigard

    The user enters two city names and then presses the Compare button to interact with the '/create' path in the backend. 

    2. UPDATE button: If the developer has updated new city information in the GitHub file linked by CI/CD, the updated city is displayed with a blue marker on Google Maps. City information is retrieved through a GET request to the backend '/update-database'. 

    3. Click on marker: When you click on the marker displayed on Google Maps, a transparent black box is created by interacting with the React state variable isButton state variable, and 5 days of weather data is loaded through the map function above it. The html component requests temperature and precipitation graphs to the '/bringgraphs' backend path. The graph is stored on the client through Redux.js.

### Technologies Used

Build components through the Vite React app.
The libraries used are as follows:

1. React.js
2. Redux.js
3. Emotion
4. JWTdecode
5. Google Map API

To get the icon for the Weather Open API, use the following URL: 
http://openweathermap.org/img/wn/${icons}@2x.png


### Installation

Developers can run it using npm run dev. To avoid the hassle of downloading react and redux through npm install, we used a Docker image.

### Usage

To Expo we provided the URL where we deployed the web page. Please go here. (Link to be updated)


## Backend

### Overview

Requests coming into the front end are processed through the Flask RESTful API. Since the Jupyter notebook is responsible for graph requests, a new request is sent through the request method. If updates to the database are required, they are handled within the backend. It is connected to port number 8080 and accepts requests from all routes. server.py is the Docker file version, and app.py is the local version. If there is additional code, temporarily modify the code in app.py and update it with the Docker file version. It is divided into two files, post and get, using a blue printer. The post file only processes post requests, and get only processes get requests. Data is broadly divided into three categories: city data, user data, and graph data. 

- City data: Load two city data as the request body.

- User data: Verify that the ID and password match the AWS database.

- Graph data: Image data (png) coming into the Jupyter notebook is encoded in base64 and loaded.

### Technologies Used

API used:

Flask==3.0.0
python-dotenv>=0.19.2
flask-cors
requests>=2.27.1
json2html
python-jose
pymysql
gunicorn
bcrypt
cryptography
jupyter
mysql-connector-python
folium
pyjwt


### REST API and Path

'./login': Responsible for logging in.

'./rain': This is the code requested when a marker is clicked. It requests 5 days' worth of precipitation and temperature graphs from the Jupyter notebook and sends them back to the frontend.

'./create': Select two cities and send data for both cities to a Jupyter notebook. The Jupyter notebook draws a comparison graph of max_temp, min_temp, humidity, and pressure, stores it in the AWS database, and returns the ID to the backend. Data is searched through the returned ID and then transmitted to the front end.

'./bringgraphs': Update the database. This code is not visible because it does not interact with the user client.

### Port and Dockerizing
 
Usage of 'gunicon' and port number is 8080

### Installation

```bash
    pip install -r requirements.txt
```

### Usage

```bash
    pip install -r requirements.txt
    docker build -t backend .
    docker run -p 8080:8080 backend
```

## Jupyter Notebook

### Overview

Jupyter Notebook is used for data analysis, visualization, and modeling.

1. drawing graph

### Technologies Used

List the technologies and libraries used in the Jupyter Notebook.

1. pandas ```import pandas as pd```
2. flask ```from flask import Flask, request, jsonify```
3. MySql ```import pymysql```
4. matplotlib ```import matplotlib.pyplot as plt```
5. datetime ```from datetime import datetime, timedelta```
6. flask_cors ```from flask_cors import CORS```
7. base64 ```import base64```
8. io ```from io import BytesIO```
9. os ```import os```

### Installation

Provide instructions on how to set up and run the Jupyter Notebook environment.

### Usage

Explain how to use Jupyter Notebook for data analysis and modeling.

## Installation

1. cd Into the folder jupyter using the command ```cd jupyter``` in your terminal
2. run the command ```docker build -t jupyter```

## Usage

1. Run the docker immage along side the other 3 docker immages

## Contributing

Please make your changes to the `drawdata.ipynb` file and push them to the `jupyter` branch. Do not push to the `release` branch, as it is reserved for stable releases only.

## License

Open source. Please just cite your source thank you
